'''
민식이는 다음과 같은 폴리오미노 2개를 무한개만큼 가지고 있다. AAAA와 BB
이제 '.'와 'X'로 이루어진 보드판이 주어졌을 때, 민식이는 겹침없이 'X'를 모두 폴리오미노로 덮으려고 한다. 이때, '.'는 폴리오미노로 덮으면 안 된다.
폴리오미노로 모두 덮은 보드판을 출력하는 프로그램을 작성하시오.

입력 : 첫째 줄에 보드판이 주어진다. 보드판의 크기는 최대 50
출력 : 첫째 줄에 사전순으로 가장 앞서는 답을 출력한다. 만약 덮을 수 없으면 -1을 출력한다.

< 아이디어 >
1. 보드판은 한줄로 주어진다.
2. 두 개의 폴리오미노는 모두 짝수개이다. 홀수개인 칸은 채울 수 없다. 즉, 홀수개인 칸이 있으면 -1을 출력한다.
3. 입력받은 보드판을 . 기준으로 자른다. 여러개 있는 경우 공백인 원소는 제거? 나머지 원소의 길이를 확인하고, 홀수개가 있으면 종료
4. 짝수개인 원소에 대해서는 그리디하게 한다.

1. '.'을 만나기 전까지 X 개수를 카운트 한다. 인덱스를 센다. start와 end 인덱스 확인
2. X 개수가 홀수개이면 -1을 출력한다.
3. X 개수가 짝수개이면 그리디하게 A를 넣을건인지, B를 넣을지 정하고 문자열을 바꿔서 넣어준다.

1. XXXX를 먼저 AAAA로 바꾸어준다
2. XX를 BB로 바꾸어준다
3. X가 남아있으면 -1 출력
개 충 격
'''

# 처음, 두번째 아이디어 해보다 말았음
import sys
input = sys.stdin.readline

# 보드판 입력받기
board = input()
count_X = 0
start = 0
end = 0

for _ in board:
    # X 개수 카운트하기
    if _ == 'X':
        count_X += 1
    else:
        count_X == 0

    # X 개수가 홀수개이면 -1 출력 후 종료
    if count_X % 2 != 0:
        print(-1)
        break



# 답지 아이디어

board = input()
board = board.replace('XXXX','AAAA')
board = board.replace('XX','BB')

if 'X' in board:
    print(-1)
else:
    print(board)